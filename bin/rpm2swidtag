#!/usr/bin/python3

from sys import argv, exit, stderr, stdout
from os import getenv, path, makedirs
from platform import node
from rpm2swidtag import Template, Error, rpm
import argparse, re
from configparser import ConfigParser
from glob import iglob

TEMPLATE_DIR = "/etc/rpm2swidtag"
CONFIG_FILE = "/etc/rpm2swidtag/rpm2swidtag.conf"

def setup_opts():
	parser = argparse.ArgumentParser(description='SWID tag parameters.')
	group1 = parser.add_mutually_exclusive_group()
	group1.add_argument('-a', '--all', dest='all', action='store_true', help='query all packages with glob pattern')
	group1.add_argument('-p', '--package', dest='rpmfile', action='store_true', help='process rpm package file')
	parser.add_argument('--regid', type=str, help="tag creator's regid")
	parser.add_argument('--output-dir', type=str, metavar='DIR',
		help="write SWID tags files into regid subdirectory of DIR; or directly into DIR when the path ends with /.")
	group2 = parser.add_mutually_exclusive_group()
	group2.add_argument('--authoritative', action='store_true', help="produce authoritative tag (per NIST.IR.8060) with Payload, rather than Evidence")
	group2.add_argument('--evidence-deviceid', type=str, dest='device', default=node(), help="Evidence/@deviceId string, defaults to hostname")
	parser.add_argument('--primary-only', action='store_true', help="do not generate supplemental tags")
	parser.add_argument('--print-tagid', action='store_true', help="compute and print tagId(s) to standard output")
	parser.add_argument('--software-creator-from', metavar='FILE', help="set softwareCreator Entity to value in referenced file")
	other_group = parser.add_argument_group("config options")
	other_group.add_argument('--config', default=CONFIG_FILE, metavar='FILE', help="location of the configuration file")
	parser.add_argument('package', type=str, nargs='*', help='package(s), glob(s) or file name(s)', metavar='...')
	return parser.parse_args()

def load_config(opts):
	config = ConfigParser(delimiters = '=', comment_prefixes = '#')
	config['rpm2swidtag'] = { 'config-file': opts.config, 'template-dir': TEMPLATE_DIR }
	config.read(opts.config)
	config.read(sorted(iglob(opts.config + ".d/*.conf")))
	return config

def load_template(config, opts):
	template = None
	try:
		template_dir = path.join(path.dirname(config.get('rpm2swidtag', 'config-file')),
			config.get('rpm2swidtag', 'template-dir'))
		xml_template = getenv('RPM2SWIDTAG_TEMPLATE', template_dir + "/template.swidtag")
		if opts.print_tagid:
			xslt_file = getenv('RPM2SWIDTAG_XSLT', template_dir + "/rpm2swidtag-tagid.xslt")
		else:
			xslt_file = getenv('RPM2SWIDTAG_XSLT', template_dir + "/rpm2swidtag.xslt")
		return Template(xml_template, xslt_file)
	except Error as e:
		stderr.write("%s: %s\n" % (argv[0], e.strerror))
		exit(5)

def write_out_tag(tag, opts, supplemental=False):
	if opts.output_dir and not opts.print_tagid:
		if opts.output_dir.endswith("/."):
			dir = opts.output_dir
		else:
			dir = opts.output_dir + '/' + tag.get_tagcreator_regid()
		if not path.exists(dir):
			makedirs(dir)
		tag.write_output(dir + '/' + tag.get_tagid() + '.swidtag')
	else:
		if opts.print_tagid and supplemental:
			stdout.buffer.write(b"+ ")
		tag.write_output(stdout.buffer)


def process_rpm_with_template(header, template, opts, config):
	params = {}
	if opts.regid:
		params['tagcreator-regid'] = opts.regid
	if opts.authoritative:
		params['authoritative'] = 'true'
	else:
		params['deviceid'] = opts.device

	signature_key_id = rpm.get_signature_key_id(header)
	component_of = None
	if signature_key_id:
		for s in config.sections():
			if not re.search(r'^link\s', s):
				continue
			if config.get(s, 'key-id') \
				and config.get(s, 'key-id') == signature_key_id:
				creator_from = config.get(s, 'software-creator-file', fallback=None)
				if creator_from:
					creator_from = path.abspath(creator_from)
				if creator_from and path.isfile(creator_from):
					params['software-creator-from'] = creator_from

				component_of = config.get(s, 'component-of-file', fallback=None)
				if component_of:
					component_of = path.abspath(component_of)
				if component_of and not path.isfile(component_of):
					component_of = None
				break
	if opts.software_creator_from:
		params['software-creator-from'] = path.abspath(opts.software_creator_from)
	write_out_tag(template.generate_tag_for_header(header, params=params), opts)
	if not opts.primary_only and component_of:
		params['component-of'] = component_of
		write_out_tag(template.generate_tag_for_header(header, params=params), opts, supplemental=True)

def main():
	opts = setup_opts()
	config = load_config(opts)
	template = load_template(config, opts)

	if opts.all and not opts.package:
		opts.package = [ '*' ]

	exit_status = 0
	for p in opts.package:
		try:
			if opts.rpmfile:
				l = [ rpm.read_from_file(p) ]
			else:
				# We only assume the use of _RPM2SWIDTAG_RPMDBPATH for testing, really
				l = rpm.read_from_db(p, rpmdb_path=getenv('_RPM2SWIDTAG_RPMDBPATH'),
					glob=opts.all)
		except Error as e:
			stderr.write("%s: %s\n" % (argv[0], e.strerror))
			exit_status = 3
			continue

		found = False
		for h in l:
			found = True
			try:
				process_rpm_with_template(h, template, opts, config)
				stdout.flush()
			except Error as e:
				if opts.rpmfile:
					msg = "for file [%s]" % p
				else:
					msg = "for package [%s]" % p
				stderr.write("%s: Error generating SWID tag %s: %s\n" % (argv[0], msg, e.strerror))
				exit(6)
			except BrokenPipeError as e:
				stderr.close()
				return exit_status
		if not found:
			stderr.write("%s: No package [%s] found in database\n" % (argv[0], p))
			exit_status = 7

	return exit_status

if __name__ == '__main__':
	exit(main())
